"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discoverMissingExports = exports.load = void 0;
const typedoc_1 = require("typedoc");
function load(app) {
    app.options.addDeclaration({
        name: "internalNamespace",
        help: "Define the name of the namespace that internal symbols which are not exported should be placed into.",
        defaultValue: "<internal>",
    });
    const knownPrograms = new Map();
    app.converter.on(typedoc_1.Converter.EVENT_CREATE_DECLARATION, (context) => {
        if (context.scope.kindOf(typedoc_1.ReflectionKind.Project | typedoc_1.ReflectionKind.Module)) {
            knownPrograms.set(context.scope, context.program);
        }
    });
    app.converter.on(typedoc_1.Converter.EVENT_RESOLVE_BEGIN, onResolveBegin.bind(void 0, knownPrograms), void 0, 1e9);
}
exports.load = load;
function onResolveBegin(knownPrograms, context) {
    var _a;
    const modules = context.project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
    if (modules.length === 0) {
        // Single entry point, just target the project.
        modules.push(context.project);
    }
    for (const mod of modules) {
        let missing = discoverMissingExports(mod);
        if (missing.size === 0)
            continue;
        // Nasty hack here that will almost certainly break in future TypeDoc versions.
        context.setActiveProgram(knownPrograms.get(mod));
        const internalNs = context
            .withScope(mod)
            .createDeclarationReflection(typedoc_1.ReflectionKind.Namespace, void 0, void 0, context.converter.application.options.getValue("internalNamespace"));
        context.finalizeDeclarationReflection(internalNs, void 0);
        const internalContext = context.withScope(internalNs);
        // Keep track of which symbols we've tried to convert. If they don't get converted
        // when calling convertSymbol, then the user has excluded them somehow, don't go into
        // an infinite loop when converting.
        const tried = new Set();
        do {
            for (const s of missing) {
                if (shouldConvertSymbol(s, context.checker)) {
                    internalContext.converter.convertSymbol(internalContext, s);
                }
                tried.add(s);
            }
            missing = discoverMissingExports(internalNs);
            for (const s of tried) {
                missing.delete(s);
            }
        } while (missing.size > 0);
        // All the missing symbols were excluded, so get rid of our namespace.
        if (!((_a = internalNs.children) === null || _a === void 0 ? void 0 : _a.length)) {
            context.project.removeReflection(internalNs);
        }
        context.setActiveProgram(void 0);
    }
    knownPrograms.clear();
}
function discoverMissingExports(root) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const missing = new Set();
    const queue = [];
    let current = root;
    const visitor = (0, typedoc_1.makeRecursiveVisitor)({
        reference(type) {
            if (!type.reflection) {
                const symbol = type.getSymbol();
                if (symbol) {
                    missing.add(symbol);
                }
            }
        },
        reflection(type) {
            queue.push(type.declaration);
        },
    });
    const add = (item) => {
        if (!item)
            return;
        if (item instanceof typedoc_1.Reflection) {
            queue.push(item);
        }
        else {
            queue.push(...item);
        }
    };
    do {
        // Ugly? Yeah, it is. TypeDoc doesn't have a "visit all types" function,
        // so we have to build our own. This is modeled after the one in
        // https://github.com/TypeStrong/typedoc/blob/beta/src/lib/validation/exports.ts
        if (current instanceof typedoc_1.ContainerReflection) {
            add(current.children);
        }
        if (current instanceof typedoc_1.DeclarationReflection) {
            (_a = current.type) === null || _a === void 0 ? void 0 : _a.visit(visitor);
            add(current.typeParameters);
            add(current.signatures);
            add(current.indexSignature);
            add(current.getSignature);
            add(current.setSignature);
            (_b = current.overwrites) === null || _b === void 0 ? void 0 : _b.visit(visitor);
            (_c = current.inheritedFrom) === null || _c === void 0 ? void 0 : _c.visit(visitor);
            (_d = current.implementationOf) === null || _d === void 0 ? void 0 : _d.visit(visitor);
            (_e = current.extendedTypes) === null || _e === void 0 ? void 0 : _e.forEach((type) => type.visit(visitor));
            // do not validate extendedBy, guaranteed to all be in the documentation.
            (_f = current.implementedTypes) === null || _f === void 0 ? void 0 : _f.forEach((type) => type.visit(visitor));
            // do not validate implementedBy, guaranteed to all be in the documentation.
        }
        if (current instanceof typedoc_1.SignatureReflection) {
            add(current.parameters);
            add(current.typeParameters);
            (_g = current.type) === null || _g === void 0 ? void 0 : _g.visit(visitor);
            (_h = current.overwrites) === null || _h === void 0 ? void 0 : _h.visit(visitor);
            (_j = current.inheritedFrom) === null || _j === void 0 ? void 0 : _j.visit(visitor);
            (_k = current.implementationOf) === null || _k === void 0 ? void 0 : _k.visit(visitor);
        }
        if (current instanceof typedoc_1.ParameterReflection) {
            (_l = current.type) === null || _l === void 0 ? void 0 : _l.visit(visitor);
        }
        if (current instanceof typedoc_1.TypeParameterReflection) {
            (_m = current.type) === null || _m === void 0 ? void 0 : _m.visit(visitor);
            (_o = current.default) === null || _o === void 0 ? void 0 : _o.visit(visitor);
        }
    } while ((current = queue.shift()));
    return missing;
}
exports.discoverMissingExports = discoverMissingExports;
function shouldConvertSymbol(symbol, checker) {
    while (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Alias) {
        symbol = checker.getAliasedSymbol(symbol);
    }
    // We're looking at an unknown symbol which is declared in some package without
    // type declarations. We know nothing about it, so don't convert it.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Transient) {
        return false;
    }
    // This is something inside the special Node `Globals` interface. Don't convert it
    // because TypeDoc will reasonably assert that "Property" means that a symbol should be
    // inside something that can have properties.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Property) {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map